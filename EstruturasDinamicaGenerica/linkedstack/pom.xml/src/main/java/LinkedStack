

/**
 * Implementação de uma Pilha Dinâmica
 *
 * @param <T> o tipo de elementos armazenados na Pilha
 *
 * @author Alessa Nader
 * @version 1.0
 * @since 06/10/2025
 */

import java.util.NoSuchElementException;

public class LinkedStack<T> implements Stackable {

    // Guarda a referência para o último item inserido (topo da pilha)
    private DoubleNode<T> topPointer;

    // Controla quantos elementos estão atualmente armazenados
    private int numberElements;

    // Define o limite máximo de elementos que a pilha pode ter
    private int maxElements;

    // Cria uma pilha com capacidade padrão de 10 posições
    public LinkedStack() {
        this(10);
    }

    // Cria uma pilha com capacidade definida pelo usuário
    public LinkedStack(int maxElements) {
        this.topPointer = null;     // Começa vazia, sem nenhum nó no topo
        this.numberElements = 0;    // Contagem inicial é zero
        this.maxElements = maxElements; // Define a capacidade máxima
    }

    @Override
    public T peek() {
        // Se não há nada na pilha, não há topo para visualizar
        if (isEmpty()) {
            throw new NoSuchElementException("Stack is empty");
        }
        // Retorna o conteúdo do topo sem removê-lo
        return topPointer.getData();
    }

    @Override
    public void push(T data) {
        // Impede adicionar mais elementos se a pilha estiver cheia
        if (isFull()) {
            throw new NoSuchElementException("Stack is full");
        }

        // Cria um novo nó para guardar o valor informado
        DoubleNode<T> newNode = new DoubleNode<T>();
        newNode.setData(data);

        // Liga o novo nó ao topo atual da pilha (como se colocasse algo por cima)
        newNode.setPrior(topPointer);

        // Se já havia um topo, faz o topo anterior apontar para o novo nó
        if (topPointer != null) {
            topPointer.setNext(newNode);
        }

        // Atualiza o topo da pilha para ser o novo nó inserido
        topPointer = newNode;

        // Incrementa o número de elementos
        numberElements++;
    }

    @Override
    public T pop() {
        // Não é possível remover algo de uma pilha vazia
        if (isEmpty()) {
            throw new NoSuchElementException("Stack is empty");
        }

        // Guarda o valor do topo antes de remover
        T auxData = topPointer.getData();

        // Move o ponteiro de topo para o elemento abaixo
        topPointer = topPointer.getPrior();

        // Se ainda há elementos, desconecta o novo topo do nó removido
        if (topPointer != null) {
            topPointer.setNext(null);
        }

        // Diminui a contagem total
        numberElements--;

        // Retorna o dado que foi removido
        return auxData;
    }

    @Override
    public void update(Object newData) {
        // Substitui o valor do topo removendo o atual e empilhando o novo
        pop();
        push((T) newData);
    }

    @Override
    public boolean isFull() {
        // A pilha está cheia quando atinge o número máximo permitido
        return numberElements == maxElements;
    }

    @Override
    public boolean isEmpty() {
        // Está vazia quando não há nenhum elemento guardado
        return numberElements == 0;
    }

    @Override
    public String print() {
        // Monta uma string com os dados da pilha (do topo até a base)
        String result = "";

        // Começa a leitura a partir do topo
        DoubleNode<T> auxPointer = topPointer;

        // Percorre os elementos de cima para baixo
        for (int i = 0; i < numberElements; i++) {
            result += auxPointer.getData();   // adiciona o valor do nó atual
            auxPointer = auxPointer.getPrior(); // desce um nível na pilha

            // Adiciona vírgula entre os valores, exceto no último
            if (i != numberElements - 1) {
                result += ", ";
            }
        }

        // Retorna a lista completa formatada com colchetes
        return "[" + result + "]";
    }
}
